{"version":3,"file":"index-Cjfam9dp.js","sources":["../../src/components/Cesium/CesiumBase/index.ts"],"sourcesContent":["import { SkyBox, Cartesian3, PostProcessStage, Cartesian4, Color } from 'cesium'\r\nimport * as Cesium from 'cesium'\r\n\r\nclass CesiumBase {\r\n  // 天空盒\r\n  static setOneSkyBox() {\r\n    return new SkyBox({\r\n      sources: {\r\n        positiveX: 'src/assets/SkyBox/00h+00.jpg',\r\n        negativeX: 'src/assets/SkyBox/12h+00.jpg',\r\n        positiveY: 'src/assets/SkyBox/06h+00.jpg',\r\n        negativeY: 'src/assets/SkyBox/18h+00.jpg',\r\n        positiveZ: 'src/assets/SkyBox/06h+90.jpg',\r\n        negativeZ: 'src/assets/SkyBox/06h-90.jpg'\r\n      }\r\n    })\r\n  }\r\n\r\n  // 天空盒2\r\n  static setTwoSkyBox() {\r\n    return new SkyBox({\r\n      sources: {\r\n        positiveX: 'src/assets/SkyBox/Version2_dark_px.jpg',\r\n        negativeX: 'src/assets/SkyBox/Version2_dark_mx.jpg',\r\n        positiveY: 'src/assets/SkyBox/Version2_dark_py.jpg',\r\n        negativeY: 'src/assets/SkyBox/Version2_dark_my.jpg',\r\n        positiveZ: 'src/assets/SkyBox/Version2_dark_pz.jpg',\r\n        negativeZ: 'src/assets/SkyBox/Version2_dark_mz.jpg'\r\n      }\r\n    })\r\n  }\r\n\r\n  // 天空盒3\r\n  static setThreeSkyBox() {\r\n    return new SkyBox({\r\n      sources: {\r\n        positiveX: 'src/assets/SkyBox/tycho2t3_80_pxs.jpg',\r\n        negativeX: 'src/assets/SkyBox/tycho2t3_80_mxs.jpg',\r\n        positiveY: 'src/assets/SkyBox/tycho2t3_80_pys.jpg',\r\n        negativeY: 'src/assets/SkyBox/tycho2t3_80_mys.jpg',\r\n        positiveZ: 'src/assets/SkyBox/tycho2t3_80_pzs.jpg',\r\n        negativeZ: 'src/assets/SkyBox/tycho2t3_80_mzs.jpg'\r\n      }\r\n    })\r\n  }\r\n\r\n  //黑夜特效\r\n  static setDarkEffect(options) {\r\n    options = options || {}\r\n    const fs =\r\n      'uniform sampler2D colorTexture;\\n' +\r\n      'varying vec2 v_textureCoordinates;\\n' +\r\n      'uniform float scale;\\n' +\r\n      'uniform vec3 offset;\\n' +\r\n      'void main() {\\n' +\r\n      ' // vec4 color = texture2D(colorTexture, v_textureCoordinates);\\n' +\r\n      ' vec4 color = texture2D(colorTexture, v_textureCoordinates);\\n' +\r\n      ' // float gray = 0.2989*color.r+0.5870*color.g+0.1140*color.b;\\n' +\r\n      ' // gl_FragColor = vec4(gray,gray,2.0*(gray+1.0), 1.0);\\n' +\r\n      ' gl_FragColor = vec4(color.r*0.2,color.g * 0.4,color.b*0.6, 1.0);\\n' +\r\n      '}\\n'\r\n    return new PostProcessStage({\r\n      name: 'darkEffect',\r\n      fragmentShader: fs,\r\n      uniforms: {\r\n        scale: options.scale || 1.0,\r\n        offset: options.offset || new Cartesian3(0.1, 0.2, 0.3)\r\n      }\r\n    })\r\n  }\r\n\r\n  //场景蓝光\r\n  //  colorTexture1 不支持\r\n  // static setBlurBloom(options) {\r\n  //   options = options || {}\r\n  //   const fs =\r\n  //     'uniform float height;\\n' +\r\n  //     'uniform float width;\\n' +\r\n  //     'uniform sampler2D colorTexture;\\n' +\r\n  //     '\\n' +\r\n  //     'varying vec2 v_textureCoordinates;\\n' +\r\n  //     '\\n' +\r\n  //     'const int SAMPLES = 9;\\n' +\r\n  //     'void main()\\n' +\r\n  //     '{\\n' +\r\n  //     'vec2 st = v_textureCoordinates;\\n' +\r\n  //     'float wr = float(1.0 / width);\\n' +\r\n  //     'float hr = float(1.0 / height);\\n' +\r\n  //     'vec4 result = vec4(0.0);\\n' +\r\n  //     'int count = 0;\\n' +\r\n  //     'for(int i = -SAMPLES; i <= SAMPLES; ++i){\\n' +\r\n  //     'for(int j = -SAMPLES; j <= SAMPLES; ++j){\\n' +\r\n  //     'vec2 offset = vec2(float(i) * wr, float(j) * hr);\\n' +\r\n  //     'result += texture2D(colorTexture, st + offset);\\n' +\r\n  //     '}\\n' +\r\n  //     '}\\n' +\r\n  //     'result = result / float(count);\\n' +\r\n  //     'gl_FragColor = result;\\n' +\r\n  //     '}\\n'\r\n  //   return new PostProcessStage({\r\n  //     name: 'blur_x_direction',\r\n  //     fragmentShader: fs,\r\n  //     uniforms: {\r\n  //       width: options.width,\r\n  //       height: options.height,\r\n  //       colorTexture: 'Bright'\r\n  //     }\r\n  //   })\r\n  // }\r\n\r\n  //雨天特效\r\n  static setRainEffect() {\r\n    const fs =\r\n      'uniform sampler2D colorTexture;\\n\\\r\n                varying vec2 v_textureCoordinates;\\n\\\r\n                \\n\\\r\n                float hash(float x){\\n\\\r\n                return fract(sin(x*23.3)*13.13);\\n\\\r\n                }\\n\\\r\n                \\n\\\r\n                void main(){\\n\\\r\n                    float time = czm_frameNumber / 60.0;\\n\\\r\n                    vec2 resolution = czm_viewport.zw;\\n\\\r\n                    vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\\n\\\r\n                    vec3 c=vec3(.6,.7,.8);\\n\\\r\n                    float a=-.4;\\n\\\r\n                    float si=sin(a),co=cos(a);\\n\\\r\n                    uv*=mat2(co,-si,si,co);\\n\\\r\n                    uv*=length(uv+vec2(0,4.9))*.3+1.;\\n\\\r\n                    float v=1.-sin(hash(floor(uv.x*100.))*2.);\\n\\\r\n                    float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.;\\n\\\r\n                    c*=v*b;\\n\\\r\n                    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(c, 1), 0.2);\\n\\\r\n                }\\n\\\r\n                '\r\n    return new PostProcessStage({\r\n      name: 'rainEffect',\r\n      fragmentShader: fs\r\n    })\r\n  }\r\n\r\n  //雪天特效\r\n  static setSnowEffect() {\r\n    const fs =\r\n      'uniform sampler2D colorTexture;\\n\\\r\n    varying vec2 v_textureCoordinates;\\n\\\r\n    \\n\\\r\n    float snow(vec2 uv,float scale){\\n\\\r\n        float time = czm_frameNumber / 60.0;\\n\\\r\n        float w=smoothstep(1.,0.,-uv.y*(scale/10.));\\n\\\r\n        if(w<.1)return 0.;\\n\\\r\n        uv+=time/scale;\\n\\\r\n        uv.y+=time*2./scale;\\n\\\r\n        uv.x+=sin(uv.y+time*.5)/scale;\\n\\\r\n        uv*=scale;\\n\\\r\n        vec2 s=floor(uv),f=fract(uv),p;\\n\\\r\n        float k=3.,d;\\n\\\r\n        p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;\\n\\\r\n        d=length(p);\\n\\\r\n        k=min(d,k);\\n\\\r\n        k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\\n\\\r\n        return k*w;\\n\\\r\n    }\\n\\\r\n    \\n\\\r\n    void main(){\\n\\\r\n        vec2 resolution = czm_viewport.zw;\\n\\\r\n        vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\\n\\\r\n        vec3 finalColor=vec3(0);\\n\\\r\n        float c = 0.0;\\n\\\r\n        c+=snow(uv,30.)*.0;\\n\\\r\n        c+=snow(uv,20.)*.0;\\n\\\r\n        c+=snow(uv,15.)*.0;\\n\\\r\n        c+=snow(uv,10.);\\n\\\r\n        c+=snow(uv,8.);\\n\\\r\n        c+=snow(uv,6.);\\n\\\r\n        c+=snow(uv,5.);\\n\\\r\n        finalColor=(vec3(c));\\n\\\r\n        gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1), 0.3);\\n\\\r\n        \\n\\\r\n    }\\n\\\r\n    '\r\n    return new PostProcessStage({\r\n      name: 'snowEffect',\r\n      fragmentShader: fs\r\n    })\r\n  }\r\n\r\n  // 雾天特效\r\n  static setFogEffect() {\r\n    const fs =\r\n      'float getDistance(sampler2D depthTexture, vec2 texCoords) \\n' +\r\n      '{ \\n' +\r\n      '    float depth = czm_unpackDepth(texture2D(depthTexture, texCoords)); \\n' +\r\n      '    if (depth == 0.0) { \\n' +\r\n      '        return czm_infinity; \\n' +\r\n      '    } \\n' +\r\n      '    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth); \\n' +\r\n      '    return -eyeCoordinate.z / eyeCoordinate.w; \\n' +\r\n      '} \\n' +\r\n      'float interpolateByDistance(vec4 nearFarScalar, float distance) \\n' +\r\n      '{ \\n' +\r\n      '    float startDistance = nearFarScalar.x; \\n' +\r\n      '    float startValue = nearFarScalar.y; \\n' +\r\n      '    float endDistance = nearFarScalar.z; \\n' +\r\n      '    float endValue = nearFarScalar.w; \\n' +\r\n      '    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0); \\n' +\r\n      '    return mix(startValue, endValue, t); \\n' +\r\n      '} \\n' +\r\n      'vec4 alphaBlend(vec4 sourceColor, vec4 destinationColor) \\n' +\r\n      '{ \\n' +\r\n      '    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a); \\n' +\r\n      '} \\n' +\r\n      'uniform sampler2D colorTexture; \\n' +\r\n      'uniform sampler2D depthTexture; \\n' +\r\n      'uniform vec4 fogByDistance; \\n' +\r\n      'uniform vec4 fogColor; \\n' +\r\n      'varying vec2 v_textureCoordinates; \\n' +\r\n      'void main(void) \\n' +\r\n      '{ \\n' +\r\n      '    float distance = getDistance(depthTexture, v_textureCoordinates); \\n' +\r\n      '    vec4 sceneColor = texture2D(colorTexture, v_textureCoordinates); \\n' +\r\n      '    float blendAmount = interpolateByDistance(fogByDistance, distance); \\n' +\r\n      '    vec4 finalFogColor = vec4(fogColor.rgb, fogColor.a * blendAmount); \\n' +\r\n      '    gl_FragColor = alphaBlend(finalFogColor, sceneColor); \\n' +\r\n      '} \\n'\r\n    return new PostProcessStage({\r\n      name: 'fogEffect',\r\n      fragmentShader: fs,\r\n      uniforms: {\r\n        fogByDistance: new Cartesian4(10, 0.0, 200, 1.0),\r\n        fogColor: new Color(0.8, 0.8, 0.8, 0.5)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\n/***\r\n * 坐标转换 笛卡尔转84\r\n *\r\n * @param {Object} Cartesian3 三维位置坐标\r\n *\r\n * @return {Object} {lng,lat,alt} 地理坐标\r\n */\r\nconst transformCartesianToWGS84 = (cartesian) => {\r\n  if (cartesian) {\r\n    const ellipsoid = Cesium.Ellipsoid.WGS84\r\n    const cartographic = ellipsoid.cartesianToCartographic(cartesian)\r\n    return {\r\n      lng: Cesium.Math.toDegrees(cartographic.longitude),\r\n      lat: Cesium.Math.toDegrees(cartographic.latitude),\r\n      alt: cartographic.height\r\n    }\r\n  }\r\n}\r\n\r\n/***\r\n * 坐标数组转换 笛卡尔转84\r\n *\r\n * @param {Array} WSG84Arr {lng,lat,alt} 地理坐标数组\r\n * @param {Number} alt 拔高\r\n * @return {Array} Cartesian3 三维位置坐标数组\r\n */\r\nconst transformWGS84ArrayToCartesianArray = (WSG84Arr, alt) => {\r\n  if (WSG84Arr) {\r\n    return WSG84Arr\r\n      ? WSG84Arr.map(function (item) {\r\n          return transformWGS84ToCartesian(item, alt)\r\n        })\r\n      : []\r\n  }\r\n}\r\n\r\n/***\r\n * 坐标转换 84转笛卡尔\r\n *\r\n * @param {Object} {lng,lat,alt} 地理坐标\r\n *\r\n * @return {Object} Cartesian3 三维位置坐标\r\n */\r\nconst transformWGS84ToCartesian = (position, alt) => {\r\n  return position\r\n    ? Cesium.Cartesian3.fromDegrees(\r\n        position.lng || position.lon,\r\n        position.lat,\r\n        (position.alt = alt || position.alt),\r\n        Cesium.Ellipsoid.WGS84\r\n      )\r\n    : Cesium.Cartesian3.ZERO\r\n}\r\n\r\n/***\r\n * 坐标数组转换 笛卡尔转84\r\n *\r\n * @param {Array} cartesianArr 三维位置坐标数组\r\n *\r\n * @return {Array} {lng,lat,alt} 地理坐标数组\r\n */\r\nconst transformCartesianArrayToWGS84Array = (cartesianArr) => {\r\n  if (cartesianArr) {\r\n    return cartesianArr\r\n      ? cartesianArr.map(function (item) {\r\n          return transformCartesianToWGS84(item)\r\n        })\r\n      : []\r\n  }\r\n}\r\n\r\n/**\r\n * 84坐标转制图坐标\r\n * @param {Object} position {lng,lat,alt} 地理坐标\r\n * @return {Object} Cartesian3 三维位置坐标\r\n */\r\nconst transformWGS84ToCartographic = (position) => {\r\n  return position\r\n    ? Cesium.Cartographic.fromDegrees(position.lng || position.lon, position.lat, position.alt)\r\n    : Cesium.Cartographic.ZERO\r\n}\r\n\r\n/**\r\n * 拾取位置点\r\n * @param {Object} viewer\r\n * @return {Object} px Cartesian3 三维位置坐标\r\n */\r\nconst getCatesian3FromPX = (viewer, px) => {\r\n  if (viewer && px) {\r\n    const picks = viewer.scene.pick(px)\r\n    let cartesian = null\r\n    let isOn3dtiles = false,\r\n      isOnTerrain = false\r\n    if (picks instanceof Cesium.Cesium3DTileFeature) {\r\n      //模型上拾取\r\n      isOn3dtiles = true\r\n    }\r\n    // 3dtilset\r\n    if (isOn3dtiles) {\r\n      cartesian = viewer.scene.pickPosition(px)\r\n      if (cartesian) {\r\n        const cartographic = Cesium.Cartographic.fromCartesian(cartesian)\r\n        if (cartographic.height < 0) cartographic.height = 0\r\n        const lon = Cesium.Math.toDegrees(cartographic.longitude),\r\n          lat = Cesium.Math.toDegrees(cartographic.latitude),\r\n          height = cartographic.height //模型高度\r\n        cartesian = transformWGS84ToCartesian({ lng: lon, lat: lat, alt: height })\r\n      }\r\n    }\r\n    // 地形\r\n    if (!picks && (!viewer.terrainProvide) instanceof Cesium.EllipsoidTerrainProvider) {\r\n      const ray = viewer.scene.camera.getPickRay(px)\r\n      if (!ray) return null\r\n      cartesian = viewer.scene.globe.pick(ray, viewer.scene)\r\n      isOnTerrain = true\r\n    }\r\n    // 地球\r\n    if (!isOn3dtiles && !isOnTerrain) {\r\n      cartesian = viewer.scene.camera.pickEllipsoid(px, viewer.scene.globe.ellipsoid)\r\n    }\r\n    if (cartesian) {\r\n      const position = transformCartesianToWGS84(cartesian)\r\n      if (position.alt < 0) {\r\n        cartesian = transformWGS84ToCartesian(position, 0.1)\r\n      }\r\n      return cartesian\r\n    }\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * 获取84坐标的距离\r\n * @param {*} positions\r\n */\r\nconst getPositionDistance = (positions) => {\r\n  let distance = 0\r\n  for (let i = 0; i < positions.length - 1; i++) {\r\n    const point1cartographic = transformWGS84ToCartographic(positions[i])\r\n    const point2cartographic = transformWGS84ToCartographic(positions[i + 1])\r\n    const geodesic = new Cesium.EllipsoidGeodesic()\r\n    geodesic.setEndPoints(point1cartographic, point2cartographic)\r\n    let s = geodesic.surfaceDistance\r\n    s = Math.sqrt(\r\n      Math.pow(s, 2) + Math.pow(point2cartographic.height - point1cartographic.height, 2)\r\n    )\r\n    distance = distance + s\r\n  }\r\n  return distance.toFixed(3)\r\n}\r\n\r\n/**\r\n * 计算一组坐标组成的面的面积\r\n * @param {*} positions\r\n */\r\nconst getPositionsArea = (positions) => {\r\n  let result = 0\r\n  if (positions) {\r\n    let h = 0\r\n    const ellipsoid = Cesium.Ellipsoid.WGS84\r\n    positions.push(positions[0])\r\n    for (let i = 1; i < positions.length; i++) {\r\n      const oel = ellipsoid.cartographicToCartesian(transformWGS84ToCartographic(positions[i - 1]))\r\n      const el = ellipsoid.cartographicToCartesian(transformWGS84ToCartographic(positions[i]))\r\n      h += oel.x * el.y - el.x * oel.y\r\n    }\r\n    result = Math.abs(h).toFixed(2)\r\n  }\r\n  return result\r\n}\r\n\r\n/***\r\n * @description: 地球自转\r\n */\r\nclass GlobeRotate {\r\n  constructor(viewer) {\r\n    this._viewer = viewer\r\n  }\r\n\r\n  // 根据国际天体参考系计算旋转矩阵\r\n  _icrf() {\r\n    if (this._viewer.scene.mode !== Cesium.SceneMode.SCENE3D) {\r\n      return ture\r\n    }\r\n    const icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(this._viewer.clock.currentTime)\r\n    if (icrfToFixed) {\r\n      const camera = this._viewer.camera\r\n      const offset = Cesium.Cartesian3.clone(camera.position)\r\n      const transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed)\r\n      // 偏移相机，否则会场景旋转而地球不转\r\n      camera.lookAtTransform(transform, offset)\r\n    }\r\n  }\r\n\r\n  // 绑定事件\r\n  _bindEvent() {\r\n    // 转动的速度设置\r\n    this._viewer.clock.multiplier = 15 * 1000\r\n    // 初始化为单位矩阵\r\n    this._viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY)\r\n    this._viewer.scene.postUpdate.addEventListener(this._icrf, this)\r\n  }\r\n\r\n  // 解除绑定\r\n  _unbindEvent() {\r\n    this._viewer.clock.multiplier = 1\r\n    this._viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY)\r\n    this._viewer.scene.postUpdate.removeEventListener(this._icrf, this)\r\n  }\r\n\r\n  // 开始旋转\r\n  start() {\r\n    this._viewer.clock.shouldAnimate = true\r\n    this._unbindEvent()\r\n    this._bindEvent()\r\n    return this\r\n  }\r\n\r\n  // 停止旋转\r\n  stop() {\r\n    this._unbindEvent()\r\n    return this\r\n  }\r\n}\r\n\r\nexport {\r\n  CesiumBase,\r\n  GlobeRotate,\r\n  getCatesian3FromPX,\r\n  getPositionDistance,\r\n  getPositionsArea,\r\n  transformCartesianToWGS84,\r\n  transformWGS84ArrayToCartesianArray,\r\n  transformWGS84ToCartesian,\r\n  transformCartesianArrayToWGS84Array\r\n}\r\n"],"names":["CesiumBase","options","fs","transformCartesianToWGS84","cartesian","cartographic","transformWGS84ArrayToCartesianArray","WSG84Arr","alt","item","transformWGS84ToCartesian","position","transformCartesianArrayToWGS84Array","cartesianArr","transformWGS84ToCartographic","getCatesian3FromPX","viewer","px","picks","isOn3dtiles","isOnTerrain","lon","lat","height","ray","getPositionDistance","positions","distance","i","point1cartographic","point2cartographic","geodesic","getPositionsArea","result","h","ellipsoid","oel","el","GlobeRotate","icrfToFixed","camera","offset","transform"],"mappings":"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"}