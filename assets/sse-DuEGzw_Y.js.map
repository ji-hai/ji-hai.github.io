{"version":3,"file":"sse-DuEGzw_Y.js","sources":["../../src/views/SSE/sse.vue"],"sourcesContent":["<script setup lang=\"ts\">\r\nimport { ref } from 'vue'\r\nimport { ContentWrap } from '@/components/ContentWrap'\r\ndefineOptions({\r\n  name: 'SSE'\r\n})\r\n\r\nconst es = new EventSource('http://127.0.0.1:3000/sse')\r\n\r\nconst currentData = ref('')\r\n// 监听 message 事件\r\nes.onmessage = (event) => {\r\n  // 挂到载体上面\r\n  currentData.value = event.data\r\n}\r\n\r\nes.onopen = function (event) {\r\n  console.log('连接成功', event)\r\n}\r\n\r\nes.onerror = function (error) {\r\n  // 监听错误\r\n  console.log('错误', error)\r\n}\r\n</script>\r\n\r\n<template>\r\n  <ContentWrap title=\"SSE\">\r\n    <i>本例子使用node搭建服务</i>\r\n    <h1>\r\n      什么是sse（Server-Sent Events）\r\n    </h1>\r\n    <p>\r\n      SSE（Server-Sent Events）是一种用于实现服务器主动向客户端推送数据的技术，也被称为“事件流”（Event Stream）。\r\n      它基于 HTTP 协议，利用了其长连接特性，在客户端与服务器之间建立一条持久化连接，\r\n      并通过这条连接实现服务器向客户端的实时数据推送。\r\n    </p>\r\n    <h1>\r\n      SSE技术的基本原理\r\n    </h1>\r\n    <p>\r\n      <ol>\r\n        <li>\r\n          客户端向服务器发送一个GET请求，带有指定的header，表示可以接收事件流类型，并禁用任何的事件缓存。\r\n        </li>\r\n        <li>\r\n          服务器返回一个响应，带有指定的header，表示事件的媒体类型和编码，\r\n          以及使用分块传输编码（chunked）来流式传输动态生成的内容。\r\n        </li>\r\n        <li>\r\n          服务器在有数据更新时，向客户端发送一个或多个名称：值字段组成的事件，由单个换行符分隔。事件之间由两个换行符分隔。\r\n          服务器可以发送事件数据、事件类型、事件ID和重试时间等字段。\r\n        </li>\r\n        <li>\r\n          客户端使用EventSource接口来创建一个对象，打开连接，并订阅onopen、\r\n          onmessage和onerror等事件处理程序来处理连接状态和接收消息。\r\n        </li>\r\n        <li>\r\n          客户端可以使用GET查询参数来传递数据给服务器，也可以使用close方法来关闭连接。\r\n        </li>\r\n      </ol>\r\n    </p>\r\n    <h1>\r\n      数据格式\r\n    </h1>\r\n    <p>\r\n      SSE 可以传输文本和二进制格式的数据，但只支持单向数据流，即只能由服务器向客户端推送数据。\r\n      WebSocket 支持双向数据流，客户端和服务器可以互相发送消息，并且没有消息大小限制。\r\n    </p>\r\n    <h1>\r\n      代码实现\r\n    </h1>\r\n    <p>\r\n      前端：\r\n      <pre style=\"backgroundColor: #111;color: #fff\">\r\n\r\n        const es = new EventSource('http://127.0.0.1:3000/sse')\r\n        \r\n        const currentData = ref('')\r\n\r\n        // 监听 message 事件\r\n        es.onmessage = (event) => {\r\n\r\n        // 挂到载体上面\r\n        currentData.value = event.data\r\n\r\n        }\r\n\r\n        es.onopen = function (event) {\r\n\r\n          console.log('连接成功', event)\r\n\r\n        } \r\n\r\n        es.onerror = function (error) {\r\n\r\n        // 监听错误\r\n        console.log('错误', error)\r\n\r\n        }\r\n      </pre>\r\n      node:\r\n      <pre style=\"backgroundColor: #111;color: #fff\">\r\n\r\n        // 挂载路由\r\n         router.get('/sse', function(req, res, next) {\r\n\r\n           // 如果需要返回跨域头\r\n           res.setHeader('Content-Type', 'text/event-stream');\r\n\r\n           res.setHeader('Cache-Control', 'no-cache');\r\n\r\n           res.setHeader('Connection', 'keep-alive');\r\n\r\n           res.setHeader('Access-Control-Allow-Origin', '*'); // 这里修改允许跨域访问的网站\r\n\r\n           // 及时发送刷新响应头\r\n           res.flushHeaders();\r\n\r\n           setInterval(()=>{\r\n\r\n             const data = {\r\n\r\n               message: `Current time is ${new Date().toLocaleTimeString()}`\r\n\r\n             };\r\n\r\n             res.write(`data: ${JSON.stringify(data)}\\n\\n`);\r\n\r\n           }, 2000)\r\n\r\n         })\r\n      </pre>\r\n    </p>\r\n  </ContentWrap>\r\n</template>\r\n"],"names":["es","currentData","ref","event","error"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDAOM,MAAAA,EAAK,IAAI,YAAY,2BAA2B,EAEhDC,EAAcC,EAAI,EAAE,EAEvB,OAAAF,EAAA,UAAaG,GAAU,CAExBF,EAAY,MAAQE,EAAM,IAAA,EAGzBH,EAAA,OAAS,SAAUG,EAAO,CACnB,QAAA,IAAI,OAAQA,CAAK,CAAA,EAGxBH,EAAA,QAAU,SAAUI,EAAO,CAEpB,QAAA,IAAI,KAAMA,CAAK,CAAA"}